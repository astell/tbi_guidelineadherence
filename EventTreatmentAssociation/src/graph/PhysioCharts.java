package graph;

import java.awt.Color;
import java.text.SimpleDateFormat;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYDataset;

import org.jfree.data.time.Minute;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import org.jfree.chart.axis.DateAxis;

import org.jfree.ui.ApplicationFrame;

//Imports for treatment instance overlay
import org.jfree.chart.plot.Marker;
import org.jfree.chart.plot.ValueMarker;
import java.awt.BasicStroke;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

import java.util.Date;
import java.util.Vector;
import java.util.StringTokenizer;

import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;

public class PhysioCharts extends ApplicationFrame {

    /**
     * Creates a new demo.
     *
     * @param title the frame title.
     */
    public PhysioCharts(final String title, String[] paramsToView, String patientID, Date chartStart, Date chartEnd) {

        super(title);

        final XYDataset dataset = this.createDataset(paramsToView, patientID, chartStart, chartEnd);
        final JFreeChart chart = this.createChart(dataset, patientID);
        final ChartPanel chartPanel = new ChartPanel(chart);
        //chartPanel.setPreferredSize(new java.awt.Dimension(500, 270));
        chartPanel.setPreferredSize(new java.awt.Dimension(1000, 540));
        setContentPane(chartPanel);

    }

    /**
     * Creates a sample dataset.
     *
     * @return a sample dataset.
     */
    private XYDataset createDataset(String[] paramsToView, String patientID, Date chartStart, Date chartEnd) {

        //Timestamp format that will be received from the spreadsheet
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

        Vector<Vector> physioLines = new Vector<Vector>();
        String headerLine = "";

        //Open the spreadsheet file for reading (using the patientID)
        FileReader fr = null;
        BufferedReader br = null;
        String filepath = "C:\\Documents and Settings\\astell\\My Documents\\PhD\\PhD\\Data\\BrainIT_TreatmentAnalysis\\output\\";
        String filename = filepath + "" + patientID + "_physio_summary.csv";

        try {
            fr = new FileReader(filename);
            br = new BufferedReader(fr);

            //Line 3 will always be the physiological header values (use the paramsToView array to select the column number)
            br.readLine();
            br.readLine();
            headerLine = br.readLine();

            while (br.ready()) {
                Vector<String> lineValues = new Vector<String>();
                String lineIn = br.readLine();
                StringTokenizer st = new StringTokenizer(lineIn, ",");

                //Assume that there are no blanks in the files (generated by my own programs anyway to ensure this)
                while (st.hasMoreTokens()) {
                    lineValues.add(st.nextToken());
                }
                physioLines.add(lineValues);
            }
        } catch (IOException ioe) {
            System.out.println("I/O error: " + ioe.getMessage());
        }

        //Tokenize the header line and pick out the relevant index numbers
        int paramNum = paramsToView.length;
        int[] paramIndexes = new int[paramNum];
        for (int i = 0; i < paramNum; i++) {
            String headerIn = paramsToView[i];
            StringTokenizer stHeader = new StringTokenizer(headerLine, ",");
            int tokenCount = 0;
            while (stHeader.hasMoreTokens()) {
                if (headerIn.equals(stHeader.nextToken().trim())) {
                    paramIndexes[i] = tokenCount;
                }
                tokenCount++;
            }
        }

        /*
         * for (int i = 0; i < paramNum; i++) {
         * System.out.println("paramIndexes[" + i + "]: " + paramIndexes[i]); }
         */

        //Now create the series for each parameter        
        TimeSeries[] series = new TimeSeries[paramNum];
        for (int i = 0; i < paramNum; i++) {
            System.out.println("Creating TimeSeries for " + paramsToView[i] + "...");
            series[i] = new TimeSeries(paramsToView[i]);
        }

        int timestampNum = physioLines.size();
        System.out.println("timestampNum: " + timestampNum);

        try {
            for (int i = 0; i < timestampNum; i++) {

                //Get the physiological line data
                Vector<String> physioLineIn = physioLines.get(i);

                //Convert the timestamp into a date/long
                java.util.Date timestampIn = df.parse(physioLineIn.get(0));

                //System.out.println("timestampIn: " + timestampIn);

                //This is where the range setting happens
                if (chartStart == null || chartEnd == null
                        || (timestampIn.compareTo(chartStart) == 1
                        && timestampIn.compareTo(chartEnd) == -1)) {

                    //Extract the [hh:mm] values from the timestamp                    
                    Minute thisMinute = new Minute(timestampIn);

                    //NOTE: this is because we're only interested in the duration
                    //Start/stop time of monitoring will be noted in the associated demographic report
                    //Actually no: this needs to be absolute time in order to associate the treatment instances too
                    //long timestampInLong = (i+1);

                    //Add the relevant values to the correct XYSeries here
                    for (int j = 0; j < paramNum; j++) {
                        int physioLineIndex = paramIndexes[j];
                        String valueInStr = physioLineIn.get(physioLineIndex);
                        valueInStr = valueInStr.trim();
                        //Catches null feeds
                        if (valueInStr.trim().equals("-1.0")) {
                            valueInStr = "";
                        }
                        Double valueInDouble = null;
                        try {
                            double valueInD = Double.parseDouble(valueInStr);
                            valueInDouble = new Double(valueInD);
                        } catch (NumberFormatException nfe) {
                            //Catches null feeds
                            valueInDouble = new Double(Double.NaN);
                        }

                        series[j].add(thisMinute, valueInDouble);
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }

        final TimeSeriesCollection dataset = new TimeSeriesCollection();
        for (int i = 0; i < paramNum; i++) {
            dataset.addSeries(series[i]);
        }
        return dataset;
    }

    /**
     * Creates a chart.
     *
     * @param dataset the data for the chart.
     *
     * @return a chart.
     */
    private JFreeChart createChart(final XYDataset dataset, String patientID) {

        //Work out the label units
        int seriesCount = dataset.getSeriesCount();
        System.out.println("seriesCount: " + seriesCount);

        String units = "";
        for (int i = 0; i < seriesCount; i++) {
            String seriesKey = dataset.getSeriesKey(i).toString();
            if (seriesKey.matches("TC")) {
                units = "C";
            } else if (seriesKey.matches("BP.")) {
                units = "mmHg";
            } else if (seriesKey.matches("ICPm")) {
                units = "mmHg";
            } else if (seriesKey.matches("CPP")) {
                units = "mmHg";
            } else if (seriesKey.matches("HRT")) {
                units = "bpm";
            } else if (seriesKey.matches("RR")) {
                units = "bpm";
            } else if (seriesKey.matches("SaO2.")) {
                units = "mg/L";
            }
        }

        // create the chart...
        final JFreeChart chart = ChartFactory.createTimeSeriesChart(
                "Physiological Output",
                "Time",
                "Values (" + units + ")",
                dataset,
                true,
                true,
                false);

        //Get a reference to the plot for further customisation
        XYPlot plot = chart.getXYPlot();

        //Add treatment bars here (unpredictable in relation to the physiological dataset)        
        plot = this.getTreatmentMarkers(plot, patientID);
        plot = this.getEventMarkers(plot, patientID);

        //NOW DO SOME OPTIONAL CUSTOMISATION OF THE CHART
        chart.setBackgroundPaint(Color.white);

        plot.setBackgroundPaint(Color.white);
        //plot.setAxisOffset(new Spacer(Spacer.ABSOLUTE, 5.0, 5.0, 5.0, 5.0));
        plot.setDomainGridlinePaint(Color.lightGray);
        plot.setRangeGridlinePaint(Color.lightGray);

        final XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer();
        for (int i = 0; i < seriesCount; i++) {
            renderer.setSeriesLinesVisible(i, true);
            renderer.setSeriesShapesVisible(i, false);
        }
        plot.setRenderer(renderer);

        DateAxis axis = (DateAxis) plot.getDomainAxis();
        axis.setDateFormatOverride(new SimpleDateFormat("HH:mm"));

        //Change the auto tick unit selection to integer units only
        /*
         * final NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();
         * rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
         * rangeAxis.setAutoRangeIncludesZero(false);
         */
        //OPTIONAL CUSTOMISATION COMPLETED

        return chart;

    }

    private XYPlot getEventMarkers(XYPlot plot, String patientID) {
        
        SimpleDateFormat df2 = new SimpleDateFormat("EEE MMM dd hh:mm:ss zzz yyyy");
        FileReader fr = null;
        BufferedReader br = null;
        
        String[] parameterFeeds = {"Raised ICP","Lowered CPP"};        
        
        int parameterFeedNum = parameterFeeds.length;
        for (int p = 0; p < parameterFeedNum; p++) {
            for (int n = 0; n < 3; n++) {
                String parameterFeed = "" + parameterFeeds[p] + "_grade" + (n + 1);
                String filepathEvents = "C:\\Documents and Settings\\astell\\My Documents\\PhD\\PhD\\Data\\EventDetection\\output\\";
                String filenameEvents = filepathEvents + patientID + "_" + parameterFeed + "_events.csv";

                //logger.info("filenameEvents: " + filenameEvents);

                //For now, we want start, end, values and feed        
                int eventCount = 0;                
                try {
                    fr = new FileReader(filenameEvents);
                    br = new BufferedReader(fr);

                    //boolean newEvent = false;
                    int eventLineCount = 0;
                    while (br.ready()) {
                        String lineIn = br.readLine();
                        //logger.info("lineIn: " + lineIn);
                        //logger.info("eventLineCount: " + eventLineCount);

                        if (eventLineCount == 2 || eventLineCount == 3) {
                            //This is the start or end values
                            int colonIndex = lineIn.indexOf(":");
                            String timestampStr = lineIn.substring(colonIndex + 1, lineIn.length());
                            //logger.info("timestampStr: " + timestampStr);
                            timestampStr = timestampStr.trim();
                            Date eventDateTime = df2.parse(timestampStr);
                            
                            if (eventLineCount == 2) {
                                //Add the timestamp as a marker to the plot                                
                                Minute eventMin = new Minute(eventDateTime);
                                double millis = eventMin.getFirstMillisecond();
                                Marker m = new ValueMarker(millis);
                                m.setStroke(new BasicStroke(2));
                                m.setPaint(Color.GREEN);
                                //plot.addDomainMarker(m);

                                //Add the associated time-window shading
                                //this.getTimeWindowMarkers(plot, eventDateTime, true);

                            }
                        } else if (eventLineCount == 4) {
                            //This is the set of values for this event
                            StringTokenizer st = new StringTokenizer(lineIn, ",");
                            
                            eventCount++;
                        }
                        eventLineCount++;
                        if (eventLineCount == 5) {
                            eventLineCount = 0;
                        }
                    }
                } catch (Exception e) {
                    //logger.info("Error: " + e.getMessage());
                    System.out.println("Error: " + e.getMessage());
                }
            }
        }
        return plot;
    }
    
    private XYPlot getTreatmentMarkers(XYPlot plot, String patientID) {

        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

        //Read in treatment instances from patient ID file
        FileReader fr = null;
        BufferedReader br = null;
        String filepath = "C:\\Documents and Settings\\astell\\My Documents\\PhD\\PhD\\Data\\BrainIT_TreatmentAnalysis\\output\\";
        String filename = filepath + "" + patientID + "_treatment_summary.txt";

        try {
            fr = new FileReader(filename);
            br = new BufferedReader(fr);

            //Go through file until specific treatment listing is reached (not summary information)
            boolean startFileProcess = false;
            int treatmentCount = 0;
            while (br.ready()) {
                String lineIn = br.readLine();
                if (startFileProcess) {
                    //Read in line and grab timestamp
                    StringTokenizer st = new StringTokenizer(lineIn);
                    //First token is enumerator
                    st.nextToken();
                    //Second and third are the timestamp
                    String treatmentTime = st.nextToken();
                    treatmentTime += " " + st.nextToken();
                    //Fourth is the divider hyphen
                    st.nextToken();

                    st.nextToken(); //Group
                    st.nextToken(); //Value
                    String target = st.nextToken(); //Target
                    target = target.trim();

                    if (target.equals("ICP") || target.equals("CPP")) {
                        //Add the timestamp as a marker to the plot
                        java.util.Date treatmentDatetime = df.parse(treatmentTime);
                        Minute treatmentMin = new Minute(treatmentDatetime);
                        double millis = treatmentMin.getFirstMillisecond();
                        Marker m = new ValueMarker(millis);
                        m.setStroke(new BasicStroke(2));
                        m.setPaint(Color.BLUE);
                        plot.addDomainMarker(m);

                        /*if (treatmentCount == 14) {
                            //Choosing three at random because it shows up in the selected range
                            //Add the associated time-window shading
                            this.getTimeWindowMarkers(plot, treatmentDatetime, false);
                        } */                       
                    }
                    treatmentCount++;
                }

                if (lineIn.equals("====")) {
                    startFileProcess = true;
                }
            }

        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
        return plot;
    }

    private XYPlot getTimeWindowMarkers(XYPlot plot, Date eventTime, boolean isEvent) {

        //Set time-window as 30 minutes on each side of the treatment
        final boolean TIME_WINDOW_SYMMETRIC = true;
        long startToTreatment = 1800000; //This is 30 minutes in milliseconds
        float windowInMins = startToTreatment / 60000;
        long treatmentToEnd = 0;
        if (TIME_WINDOW_SYMMETRIC) {
            treatmentToEnd = startToTreatment;
        }

        //Date timeWindowStart = new Date(treatmentTime.getTime() - startToTreatment);
        Date timeWindowStart = new Date(eventTime.getTime());
        Date timeWindowEnd = new Date(eventTime.getTime() + treatmentToEnd);

        System.out.println("eventTime: " + eventTime.toString());
        System.out.println("timeWindowStart: " + timeWindowStart.toString());
        System.out.println("timeWindowEnd: " + timeWindowEnd.toString());

        Minute eventMin = new Minute(eventTime);
        Minute timeWindowStartMin = new Minute(timeWindowStart);
        Minute timeWindowEndMin = new Minute(timeWindowEnd);
        double milliStart = timeWindowStartMin.getFirstMillisecond();
        double milliEnd = timeWindowEndMin.getFirstMillisecond();
        double milliEvent = eventMin.getFirstMillisecond();

        //Time-window start-line
        Marker ms = new ValueMarker(milliStart);
        ms.setStroke(new BasicStroke(2));
        ms.setPaint(Color.BLACK);
        //plot.addDomainMarker(ms);

        if(isEvent){

            //Time-window shading
            //Marker mss = new ValueMarker(milliTreatment);
            Marker mss = new ValueMarker(milliStart);
            //Width 34 seems to work - let's assume that that is the space (30 mins) + 2 for each of the lines
            //Hmm, no - some testing suggests that a fudge-factor is always going to be needed...
            float shadingWidth = 4 + windowInMins;
            //float shadingWidth = 2;
            mss.setStroke(new BasicStroke(shadingWidth));
            mss.setPaint(Color.LIGHT_GRAY);
            plot.addDomainMarker(mss);


            //Time-window end-line
            Marker me = new ValueMarker(milliEnd);
            me.setStroke(new BasicStroke(2));
            me.setPaint(Color.BLACK);
            //plot.addDomainMarker(me);
        }

        return plot;

    }
}